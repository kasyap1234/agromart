// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: purchase_orders.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createPurchaseOrder = `-- name: CreatePurchaseOrder :one
INSERT INTO purchase_orders (tenant_id, po_number, supplier_id, location_id, created_by)
VALUES ($1, $2, $3, $4, $5)
RETURNING id, tenant_id, po_number, supplier_id, location_id, order_date, expected_delivery_date, actual_delivery_date, total_amount, tax_amount, discount_amount, final_amount, status, notes, created_by, approved_by, approved_at, created_at, updated_at
`

type CreatePurchaseOrderParams struct {
	TenantID   pgtype.UUID
	PoNumber   string
	SupplierID pgtype.UUID
	LocationID pgtype.UUID
	CreatedBy  pgtype.UUID
}

func (q *Queries) CreatePurchaseOrder(ctx context.Context, arg CreatePurchaseOrderParams) (PurchaseOrder, error) {
	row := q.db.QueryRow(ctx, createPurchaseOrder,
		arg.TenantID,
		arg.PoNumber,
		arg.SupplierID,
		arg.LocationID,
		arg.CreatedBy,
	)
	var i PurchaseOrder
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.PoNumber,
		&i.SupplierID,
		&i.LocationID,
		&i.OrderDate,
		&i.ExpectedDeliveryDate,
		&i.ActualDeliveryDate,
		&i.TotalAmount,
		&i.TaxAmount,
		&i.DiscountAmount,
		&i.FinalAmount,
		&i.Status,
		&i.Notes,
		&i.CreatedBy,
		&i.ApprovedBy,
		&i.ApprovedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createPurchaseOrderItem = `-- name: CreatePurchaseOrderItem :one
INSERT INTO purchase_order_items (tenant_id, purchase_order_id, product_id, quantity_ordered, unit_cost, total_cost)
VALUES ($1, $2, $3, $4, $5, $6)
RETURNING id, tenant_id, purchase_order_id, product_id, batch_id, quantity_ordered, quantity_received, unit_cost, total_cost, tax_percent, discount_percent, notes, created_at, updated_at
`

type CreatePurchaseOrderItemParams struct {
	TenantID        pgtype.UUID
	PurchaseOrderID pgtype.UUID
	ProductID       pgtype.UUID
	QuantityOrdered pgtype.Numeric
	UnitCost        pgtype.Numeric
	TotalCost       pgtype.Numeric
}

func (q *Queries) CreatePurchaseOrderItem(ctx context.Context, arg CreatePurchaseOrderItemParams) (PurchaseOrderItem, error) {
	row := q.db.QueryRow(ctx, createPurchaseOrderItem,
		arg.TenantID,
		arg.PurchaseOrderID,
		arg.ProductID,
		arg.QuantityOrdered,
		arg.UnitCost,
		arg.TotalCost,
	)
	var i PurchaseOrderItem
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.PurchaseOrderID,
		&i.ProductID,
		&i.BatchID,
		&i.QuantityOrdered,
		&i.QuantityReceived,
		&i.UnitCost,
		&i.TotalCost,
		&i.TaxPercent,
		&i.DiscountPercent,
		&i.Notes,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getPurchaseOrder = `-- name: GetPurchaseOrder :one
SELECT id, tenant_id, po_number, supplier_id, location_id, order_date, expected_delivery_date, actual_delivery_date, total_amount, tax_amount, discount_amount, final_amount, status, notes, created_by, approved_by, approved_at, created_at, updated_at FROM purchase_orders
WHERE id = $1 AND tenant_id = $2
`

type GetPurchaseOrderParams struct {
	ID       pgtype.UUID
	TenantID pgtype.UUID
}

func (q *Queries) GetPurchaseOrder(ctx context.Context, arg GetPurchaseOrderParams) (PurchaseOrder, error) {
	row := q.db.QueryRow(ctx, getPurchaseOrder, arg.ID, arg.TenantID)
	var i PurchaseOrder
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.PoNumber,
		&i.SupplierID,
		&i.LocationID,
		&i.OrderDate,
		&i.ExpectedDeliveryDate,
		&i.ActualDeliveryDate,
		&i.TotalAmount,
		&i.TaxAmount,
		&i.DiscountAmount,
		&i.FinalAmount,
		&i.Status,
		&i.Notes,
		&i.CreatedBy,
		&i.ApprovedBy,
		&i.ApprovedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getPurchaseOrderItems = `-- name: GetPurchaseOrderItems :many
SELECT id, tenant_id, purchase_order_id, product_id, batch_id, quantity_ordered, quantity_received, unit_cost, total_cost, tax_percent, discount_percent, notes, created_at, updated_at FROM purchase_order_items
WHERE purchase_order_id = $1 AND tenant_id = $2
`

type GetPurchaseOrderItemsParams struct {
	PurchaseOrderID pgtype.UUID
	TenantID        pgtype.UUID
}

func (q *Queries) GetPurchaseOrderItems(ctx context.Context, arg GetPurchaseOrderItemsParams) ([]PurchaseOrderItem, error) {
	rows, err := q.db.Query(ctx, getPurchaseOrderItems, arg.PurchaseOrderID, arg.TenantID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []PurchaseOrderItem
	for rows.Next() {
		var i PurchaseOrderItem
		if err := rows.Scan(
			&i.ID,
			&i.TenantID,
			&i.PurchaseOrderID,
			&i.ProductID,
			&i.BatchID,
			&i.QuantityOrdered,
			&i.QuantityReceived,
			&i.UnitCost,
			&i.TotalCost,
			&i.TaxPercent,
			&i.DiscountPercent,
			&i.Notes,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updatePurchaseOrderStatus = `-- name: UpdatePurchaseOrderStatus :exec
UPDATE purchase_orders
SET status = $1, approved_by = $2, approved_at = NOW()
WHERE id = $3 AND tenant_id = $4
`

type UpdatePurchaseOrderStatusParams struct {
	Status     string
	ApprovedBy pgtype.UUID
	ID         pgtype.UUID
	TenantID   pgtype.UUID
}

func (q *Queries) UpdatePurchaseOrderStatus(ctx context.Context, arg UpdatePurchaseOrderStatusParams) error {
	_, err := q.db.Exec(ctx, updatePurchaseOrderStatus,
		arg.Status,
		arg.ApprovedBy,
		arg.ID,
		arg.TenantID,
	)
	return err
}

// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: inventory.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const addInventoryQuantity = `-- name: AddInventoryQuantity :exec
INSERT INTO inventory (tenant_id, product_id, batch_id, quantity)
VALUES ($1, $2, $3, $4)
ON CONFLICT (tenant_id, product_id, batch_id)
DO UPDATE SET quantity = inventory.quantity + $4
`

type AddInventoryQuantityParams struct {
	TenantID  pgtype.UUID
	ProductID pgtype.UUID
	BatchID   pgtype.UUID
	Quantity  pgtype.Numeric
}

func (q *Queries) AddInventoryQuantity(ctx context.Context, arg AddInventoryQuantityParams) error {
	_, err := q.db.Exec(ctx, addInventoryQuantity,
		arg.TenantID,
		arg.ProductID,
		arg.BatchID,
		arg.Quantity,
	)
	return err
}

const createBatch = `-- name: CreateBatch :one
INSERT INTO batches (tenant_id, product_id, batch_number, expiry_date, cost)
VALUES ($1, $2, $3, $4, $5)
RETURNING id, tenant_id, product_id, batch_number, expiry_date, cost, created_at
`

type CreateBatchParams struct {
	TenantID    pgtype.UUID
	ProductID   pgtype.UUID
	BatchNumber string
	ExpiryDate  pgtype.Date
	Cost        pgtype.Numeric
}

func (q *Queries) CreateBatch(ctx context.Context, arg CreateBatchParams) (Batch, error) {
	row := q.db.QueryRow(ctx, createBatch,
		arg.TenantID,
		arg.ProductID,
		arg.BatchNumber,
		arg.ExpiryDate,
		arg.Cost,
	)
	var i Batch
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.ProductID,
		&i.BatchNumber,
		&i.ExpiryDate,
		&i.Cost,
		&i.CreatedAt,
	)
	return i, err
}

const createInventoryLog = `-- name: CreateInventoryLog :exec
INSERT INTO inventory_log (tenant_id, product_id, batch_id, transaction_type, quantity_change, reference_id, notes)
VALUES ($1, $2, $3, $4, $5, $6, $7)
`

type CreateInventoryLogParams struct {
	TenantID        pgtype.UUID
	ProductID       pgtype.UUID
	BatchID         pgtype.UUID
	TransactionType string
	QuantityChange  pgtype.Numeric
	ReferenceID     pgtype.UUID
	Notes           pgtype.Text
}

func (q *Queries) CreateInventoryLog(ctx context.Context, arg CreateInventoryLogParams) error {
	_, err := q.db.Exec(ctx, createInventoryLog,
		arg.TenantID,
		arg.ProductID,
		arg.BatchID,
		arg.TransactionType,
		arg.QuantityChange,
		arg.ReferenceID,
		arg.Notes,
	)
	return err
}

const getBatchByID = `-- name: GetBatchByID :one
SELECT id, tenant_id, product_id, batch_number, expiry_date, cost, created_at FROM batches
WHERE id = $1 AND tenant_id = $2
`

type GetBatchByIDParams struct {
	ID       pgtype.UUID
	TenantID pgtype.UUID
}

func (q *Queries) GetBatchByID(ctx context.Context, arg GetBatchByIDParams) (Batch, error) {
	row := q.db.QueryRow(ctx, getBatchByID, arg.ID, arg.TenantID)
	var i Batch
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.ProductID,
		&i.BatchNumber,
		&i.ExpiryDate,
		&i.Cost,
		&i.CreatedAt,
	)
	return i, err
}

const getInventoryByProductBatch = `-- name: GetInventoryByProductBatch :one
SELECT id, tenant_id, product_id, batch_id, quantity FROM inventory
WHERE tenant_id = $1 AND product_id = $2 AND batch_id = $3
`

type GetInventoryByProductBatchParams struct {
	TenantID  pgtype.UUID
	ProductID pgtype.UUID
	BatchID   pgtype.UUID
}

func (q *Queries) GetInventoryByProductBatch(ctx context.Context, arg GetInventoryByProductBatchParams) (Inventory, error) {
	row := q.db.QueryRow(ctx, getInventoryByProductBatch, arg.TenantID, arg.ProductID, arg.BatchID)
	var i Inventory
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.ProductID,
		&i.BatchID,
		&i.Quantity,
	)
	return i, err
}

const getInventoryLogByBatch = `-- name: GetInventoryLogByBatch :many
SELECT id, tenant_id, product_id, batch_id, transaction_type, quantity_change, transaction_date, notes, reference_id FROM inventory_log
WHERE tenant_id = $1 AND batch_id = $2
ORDER BY transaction_date DESC
LIMIT $3 OFFSET $4
`

type GetInventoryLogByBatchParams struct {
	TenantID pgtype.UUID
	BatchID  pgtype.UUID
	Limit    int32
	Offset   int32
}

func (q *Queries) GetInventoryLogByBatch(ctx context.Context, arg GetInventoryLogByBatchParams) ([]InventoryLog, error) {
	rows, err := q.db.Query(ctx, getInventoryLogByBatch,
		arg.TenantID,
		arg.BatchID,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []InventoryLog
	for rows.Next() {
		var i InventoryLog
		if err := rows.Scan(
			&i.ID,
			&i.TenantID,
			&i.ProductID,
			&i.BatchID,
			&i.TransactionType,
			&i.QuantityChange,
			&i.TransactionDate,
			&i.Notes,
			&i.ReferenceID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getInventoryLogByProduct = `-- name: GetInventoryLogByProduct :many
SELECT id, tenant_id, product_id, batch_id, transaction_type, quantity_change, transaction_date, notes, reference_id FROM inventory_log
WHERE tenant_id = $1 AND product_id = $2
ORDER BY transaction_date DESC
LIMIT $3 OFFSET $4
`

type GetInventoryLogByProductParams struct {
	TenantID  pgtype.UUID
	ProductID pgtype.UUID
	Limit     int32
	Offset    int32
}

func (q *Queries) GetInventoryLogByProduct(ctx context.Context, arg GetInventoryLogByProductParams) ([]InventoryLog, error) {
	rows, err := q.db.Query(ctx, getInventoryLogByProduct,
		arg.TenantID,
		arg.ProductID,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []InventoryLog
	for rows.Next() {
		var i InventoryLog
		if err := rows.Scan(
			&i.ID,
			&i.TenantID,
			&i.ProductID,
			&i.BatchID,
			&i.TransactionType,
			&i.QuantityChange,
			&i.TransactionDate,
			&i.Notes,
			&i.ReferenceID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getLowStockReport = `-- name: GetLowStockReport :many
SELECT p.id, p.name, p.sku, SUM(i.quantity) as total_quantity
FROM products p
JOIN inventory i ON p.id = i.product_id
WHERE p.tenant_id = $1
GROUP BY p.id
HAVING SUM(i.quantity) <= $2
`

type GetLowStockReportParams struct {
	TenantID pgtype.UUID
	Quantity pgtype.Numeric
}

type GetLowStockReportRow struct {
	ID            pgtype.UUID
	Name          string
	Sku           string
	TotalQuantity int64
}

func (q *Queries) GetLowStockReport(ctx context.Context, arg GetLowStockReportParams) ([]GetLowStockReportRow, error) {
	rows, err := q.db.Query(ctx, getLowStockReport, arg.TenantID, arg.Quantity)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetLowStockReportRow
	for rows.Next() {
		var i GetLowStockReportRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Sku,
			&i.TotalQuantity,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getProductInventoryDetails = `-- name: GetProductInventoryDetails :many
SELECT b.batch_number, b.expiry_date, i.quantity
FROM inventory i
JOIN batches b ON i.batch_id = b.id
WHERE i.tenant_id = $1 AND i.product_id = $2
ORDER BY b.expiry_date ASC
`

type GetProductInventoryDetailsParams struct {
	TenantID  pgtype.UUID
	ProductID pgtype.UUID
}

type GetProductInventoryDetailsRow struct {
	BatchNumber string
	ExpiryDate  pgtype.Date
	Quantity    pgtype.Numeric
}

func (q *Queries) GetProductInventoryDetails(ctx context.Context, arg GetProductInventoryDetailsParams) ([]GetProductInventoryDetailsRow, error) {
	rows, err := q.db.Query(ctx, getProductInventoryDetails, arg.TenantID, arg.ProductID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetProductInventoryDetailsRow
	for rows.Next() {
		var i GetProductInventoryDetailsRow
		if err := rows.Scan(&i.BatchNumber, &i.ExpiryDate, &i.Quantity); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getProductQuantity = `-- name: GetProductQuantity :one
SELECT COALESCE(SUM(quantity), 0) AS total_quantity
FROM inventory
WHERE tenant_id = $1 AND product_id = $2
`

type GetProductQuantityParams struct {
	TenantID  pgtype.UUID
	ProductID pgtype.UUID
}

func (q *Queries) GetProductQuantity(ctx context.Context, arg GetProductQuantityParams) (interface{}, error) {
	row := q.db.QueryRow(ctx, getProductQuantity, arg.TenantID, arg.ProductID)
	var total_quantity interface{}
	err := row.Scan(&total_quantity)
	return total_quantity, err
}

const listAllInventory = `-- name: ListAllInventory :many
SELECT
    i.id,
    p.name AS product_name,
    p.sku,
    b.batch_number,
    b.expiry_date,
    i.quantity,
    u.abbreviation AS unit_abbreviation
FROM inventory i
JOIN products p ON i.product_id = p.id
JOIN batches b ON i.batch_id = b.id
JOIN units u ON p.unit_id = u.id
WHERE i.tenant_id = $1
ORDER BY p.name, b.expiry_date
LIMIT $2 OFFSET $3
`

type ListAllInventoryParams struct {
	TenantID pgtype.UUID
	Limit    int32
	Offset   int32
}

type ListAllInventoryRow struct {
	ID               pgtype.UUID
	ProductName      string
	Sku              string
	BatchNumber      string
	ExpiryDate       pgtype.Date
	Quantity         pgtype.Numeric
	UnitAbbreviation string
}

func (q *Queries) ListAllInventory(ctx context.Context, arg ListAllInventoryParams) ([]ListAllInventoryRow, error) {
	rows, err := q.db.Query(ctx, listAllInventory, arg.TenantID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListAllInventoryRow
	for rows.Next() {
		var i ListAllInventoryRow
		if err := rows.Scan(
			&i.ID,
			&i.ProductName,
			&i.Sku,
			&i.BatchNumber,
			&i.ExpiryDate,
			&i.Quantity,
			&i.UnitAbbreviation,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const reduceInventoryQuantity = `-- name: ReduceInventoryQuantity :exec
UPDATE inventory
SET quantity = quantity - $1
WHERE tenant_id = $2 AND product_id = $3 AND batch_id = $4
`

type ReduceInventoryQuantityParams struct {
	Quantity  pgtype.Numeric
	TenantID  pgtype.UUID
	ProductID pgtype.UUID
	BatchID   pgtype.UUID
}

func (q *Queries) ReduceInventoryQuantity(ctx context.Context, arg ReduceInventoryQuantityParams) error {
	_, err := q.db.Exec(ctx, reduceInventoryQuantity,
		arg.Quantity,
		arg.TenantID,
		arg.ProductID,
		arg.BatchID,
	)
	return err
}

const setInventoryQuantity = `-- name: SetInventoryQuantity :exec
UPDATE inventory
SET quantity = $1
WHERE tenant_id = $2 AND product_id = $3 AND batch_id = $4
`

type SetInventoryQuantityParams struct {
	Quantity  pgtype.Numeric
	TenantID  pgtype.UUID
	ProductID pgtype.UUID
	BatchID   pgtype.UUID
}

func (q *Queries) SetInventoryQuantity(ctx context.Context, arg SetInventoryQuantityParams) error {
	_, err := q.db.Exec(ctx, setInventoryQuantity,
		arg.Quantity,
		arg.TenantID,
		arg.ProductID,
		arg.BatchID,
	)
	return err
}

const updateBatch = `-- name: UpdateBatch :one
UPDATE batches
SET batch_number = $2, expiry_date = $3, cost = $4
WHERE id = $1 AND tenant_id = $5
RETURNING id, tenant_id, product_id, batch_number, expiry_date, cost, created_at
`

type UpdateBatchParams struct {
	ID          pgtype.UUID
	BatchNumber string
	ExpiryDate  pgtype.Date
	Cost        pgtype.Numeric
	TenantID    pgtype.UUID
}

func (q *Queries) UpdateBatch(ctx context.Context, arg UpdateBatchParams) (Batch, error) {
	row := q.db.QueryRow(ctx, updateBatch,
		arg.ID,
		arg.BatchNumber,
		arg.ExpiryDate,
		arg.Cost,
		arg.TenantID,
	)
	var i Batch
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.ProductID,
		&i.BatchNumber,
		&i.ExpiryDate,
		&i.Cost,
		&i.CreatedAt,
	)
	return i, err
}

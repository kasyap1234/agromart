// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: inventory.sql

package db

import (
	"context"
	"time"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const addInventoryQuantity = `-- name: AddInventoryQuantity :exec
INSERT INTO inventory (tenant_id, product_id, batch_id, quantity)
VALUES ($1, $2, $3, $4)
ON CONFLICT (tenant_id, product_id, batch_id)
DO UPDATE SET quantity = inventory.quantity + $4
`

type AddInventoryQuantityParams struct {
	TenantID  uuid.UUID      `json:"tenant_id"`
	ProductID uuid.UUID      `json:"product_id"`
	BatchID   uuid.UUID      `json:"batch_id"`
	Quantity  pgtype.Numeric `json:"quantity"`
}

func (q *Queries) AddInventoryQuantity(ctx context.Context, arg AddInventoryQuantityParams) error {
	_, err := q.db.Exec(ctx, addInventoryQuantity,
		arg.TenantID,
		arg.ProductID,
		arg.BatchID,
		arg.Quantity,
	)
	return err
}

const createBatch = `-- name: CreateBatch :one
INSERT INTO batches (tenant_id, product_id, batch_number, expiry_date, cost)
VALUES ($1, $2, $3, $4, $5)
RETURNING id, tenant_id, product_id, batch_number, expiry_date, cost, created_at
`

type CreateBatchParams struct {
	TenantID    uuid.UUID      `json:"tenant_id"`
	ProductID   uuid.UUID      `json:"product_id"`
	BatchNumber string         `json:"batch_number"`
	ExpiryDate  time.Time      `json:"expiry_date"`
	Cost        pgtype.Numeric `json:"cost"`
}

func (q *Queries) CreateBatch(ctx context.Context, arg CreateBatchParams) (Batch, error) {
	row := q.db.QueryRow(ctx, createBatch,
		arg.TenantID,
		arg.ProductID,
		arg.BatchNumber,
		arg.ExpiryDate,
		arg.Cost,
	)
	var i Batch
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.ProductID,
		&i.BatchNumber,
		&i.ExpiryDate,
		&i.Cost,
		&i.CreatedAt,
	)
	return i, err
}

const createInventoryLog = `-- name: CreateInventoryLog :exec
INSERT INTO inventory_log (tenant_id, product_id, batch_id, transaction_type, quantity_change, reference_id, notes)
VALUES ($1, $2, $3, $4, $5, $6, $7)
`

type CreateInventoryLogParams struct {
	TenantID        uuid.UUID      `json:"tenant_id"`
	ProductID       uuid.UUID      `json:"product_id"`
	BatchID         uuid.UUID      `json:"batch_id"`
	TransactionType string         `json:"transaction_type"`
	QuantityChange  pgtype.Numeric `json:"quantity_change"`
	ReferenceID     pgtype.UUID    `json:"reference_id"`
	Notes           pgtype.Text    `json:"notes"`
}

func (q *Queries) CreateInventoryLog(ctx context.Context, arg CreateInventoryLogParams) error {
	_, err := q.db.Exec(ctx, createInventoryLog,
		arg.TenantID,
		arg.ProductID,
		arg.BatchID,
		arg.TransactionType,
		arg.QuantityChange,
		arg.ReferenceID,
		arg.Notes,
	)
	return err
}

const getBatchByID = `-- name: GetBatchByID :one
SELECT id, tenant_id, product_id, batch_number, expiry_date, cost, created_at FROM batches
WHERE id = $1 AND tenant_id = $2
`

type GetBatchByIDParams struct {
	ID       uuid.UUID `json:"id"`
	TenantID uuid.UUID `json:"tenant_id"`
}

func (q *Queries) GetBatchByID(ctx context.Context, arg GetBatchByIDParams) (Batch, error) {
	row := q.db.QueryRow(ctx, getBatchByID, arg.ID, arg.TenantID)
	var i Batch
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.ProductID,
		&i.BatchNumber,
		&i.ExpiryDate,
		&i.Cost,
		&i.CreatedAt,
	)
	return i, err
}

const getInventoryByProductBatch = `-- name: GetInventoryByProductBatch :one
SELECT id, tenant_id, product_id, batch_id, quantity FROM inventory
WHERE tenant_id = $1 AND product_id = $2 AND batch_id = $3
`

type GetInventoryByProductBatchParams struct {
	TenantID  uuid.UUID `json:"tenant_id"`
	ProductID uuid.UUID `json:"product_id"`
	BatchID   uuid.UUID `json:"batch_id"`
}

func (q *Queries) GetInventoryByProductBatch(ctx context.Context, arg GetInventoryByProductBatchParams) (Inventory, error) {
	row := q.db.QueryRow(ctx, getInventoryByProductBatch, arg.TenantID, arg.ProductID, arg.BatchID)
	var i Inventory
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.ProductID,
		&i.BatchID,
		&i.Quantity,
	)
	return i, err
}

const getInventoryLogByBatch = `-- name: GetInventoryLogByBatch :many
SELECT id, tenant_id, product_id, batch_id, transaction_type, quantity_change, transaction_date, notes, reference_id FROM inventory_log
WHERE tenant_id = $1 AND batch_id = $2
ORDER BY transaction_date DESC
LIMIT $3 OFFSET $4
`

type GetInventoryLogByBatchParams struct {
	TenantID uuid.UUID `json:"tenant_id"`
	BatchID  uuid.UUID `json:"batch_id"`
	Limit    int32     `json:"limit"`
	Offset   int32     `json:"offset"`
}

func (q *Queries) GetInventoryLogByBatch(ctx context.Context, arg GetInventoryLogByBatchParams) ([]InventoryLog, error) {
	rows, err := q.db.Query(ctx, getInventoryLogByBatch,
		arg.TenantID,
		arg.BatchID,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []InventoryLog{}
	for rows.Next() {
		var i InventoryLog
		if err := rows.Scan(
			&i.ID,
			&i.TenantID,
			&i.ProductID,
			&i.BatchID,
			&i.TransactionType,
			&i.QuantityChange,
			&i.TransactionDate,
			&i.Notes,
			&i.ReferenceID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getInventoryLogByProduct = `-- name: GetInventoryLogByProduct :many
SELECT id, tenant_id, product_id, batch_id, transaction_type, quantity_change, transaction_date, notes, reference_id FROM inventory_log
WHERE tenant_id = $1 AND product_id = $2
ORDER BY transaction_date DESC
LIMIT $3 OFFSET $4
`

type GetInventoryLogByProductParams struct {
	TenantID  uuid.UUID `json:"tenant_id"`
	ProductID uuid.UUID `json:"product_id"`
	Limit     int32     `json:"limit"`
	Offset    int32     `json:"offset"`
}

func (q *Queries) GetInventoryLogByProduct(ctx context.Context, arg GetInventoryLogByProductParams) ([]InventoryLog, error) {
	rows, err := q.db.Query(ctx, getInventoryLogByProduct,
		arg.TenantID,
		arg.ProductID,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []InventoryLog{}
	for rows.Next() {
		var i InventoryLog
		if err := rows.Scan(
			&i.ID,
			&i.TenantID,
			&i.ProductID,
			&i.BatchID,
			&i.TransactionType,
			&i.QuantityChange,
			&i.TransactionDate,
			&i.Notes,
			&i.ReferenceID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getLowStockReport = `-- name: GetLowStockReport :many
SELECT p.id, p.name, p.sku, SUM(i.quantity) as total_quantity
FROM products p
JOIN inventory i ON p.id = i.product_id
WHERE p.tenant_id = $1
GROUP BY p.id
HAVING SUM(i.quantity) <= $2
`

type GetLowStockReportParams struct {
	TenantID uuid.UUID      `json:"tenant_id"`
	Quantity pgtype.Numeric `json:"quantity"`
}

type GetLowStockReportRow struct {
	ID            uuid.UUID `json:"id"`
	Name          string    `json:"name"`
	Sku           string    `json:"sku"`
	TotalQuantity int64     `json:"total_quantity"`
}

func (q *Queries) GetLowStockReport(ctx context.Context, arg GetLowStockReportParams) ([]GetLowStockReportRow, error) {
	rows, err := q.db.Query(ctx, getLowStockReport, arg.TenantID, arg.Quantity)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetLowStockReportRow{}
	for rows.Next() {
		var i GetLowStockReportRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Sku,
			&i.TotalQuantity,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getProductInventoryDetails = `-- name: GetProductInventoryDetails :many
SELECT b.batch_number, b.expiry_date, i.quantity
FROM inventory i
JOIN batches b ON i.batch_id = b.id
WHERE i.tenant_id = $1 AND i.product_id = $2
ORDER BY b.expiry_date ASC
`

type GetProductInventoryDetailsParams struct {
	TenantID  uuid.UUID `json:"tenant_id"`
	ProductID uuid.UUID `json:"product_id"`
}

type GetProductInventoryDetailsRow struct {
	BatchNumber string         `json:"batch_number"`
	ExpiryDate  time.Time      `json:"expiry_date"`
	Quantity    pgtype.Numeric `json:"quantity"`
}

func (q *Queries) GetProductInventoryDetails(ctx context.Context, arg GetProductInventoryDetailsParams) ([]GetProductInventoryDetailsRow, error) {
	rows, err := q.db.Query(ctx, getProductInventoryDetails, arg.TenantID, arg.ProductID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetProductInventoryDetailsRow{}
	for rows.Next() {
		var i GetProductInventoryDetailsRow
		if err := rows.Scan(&i.BatchNumber, &i.ExpiryDate, &i.Quantity); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getProductQuantity = `-- name: GetProductQuantity :one
SELECT COALESCE(SUM(quantity), 0) AS total_quantity
FROM inventory
WHERE tenant_id = $1 AND product_id = $2
`

type GetProductQuantityParams struct {
	TenantID  uuid.UUID `json:"tenant_id"`
	ProductID uuid.UUID `json:"product_id"`
}

func (q *Queries) GetProductQuantity(ctx context.Context, arg GetProductQuantityParams) (interface{}, error) {
	row := q.db.QueryRow(ctx, getProductQuantity, arg.TenantID, arg.ProductID)
	var total_quantity interface{}
	err := row.Scan(&total_quantity)
	return total_quantity, err
}

const listAllInventory = `-- name: ListAllInventory :many
SELECT
    i.id,
    p.name AS product_name,
    p.sku,
    b.batch_number,
    b.expiry_date,
    i.quantity,
    u.abbreviation AS unit_abbreviation
FROM inventory i
JOIN products p ON i.product_id = p.id
JOIN batches b ON i.batch_id = b.id
JOIN units u ON p.unit_id = u.id
WHERE i.tenant_id = $1
ORDER BY p.name, b.expiry_date
LIMIT $2 OFFSET $3
`

type ListAllInventoryParams struct {
	TenantID uuid.UUID `json:"tenant_id"`
	Limit    int32     `json:"limit"`
	Offset   int32     `json:"offset"`
}

type ListAllInventoryRow struct {
	ID               uuid.UUID      `json:"id"`
	ProductName      string         `json:"product_name"`
	Sku              string         `json:"sku"`
	BatchNumber      string         `json:"batch_number"`
	ExpiryDate       time.Time      `json:"expiry_date"`
	Quantity         pgtype.Numeric `json:"quantity"`
	UnitAbbreviation string         `json:"unit_abbreviation"`
}

func (q *Queries) ListAllInventory(ctx context.Context, arg ListAllInventoryParams) ([]ListAllInventoryRow, error) {
	rows, err := q.db.Query(ctx, listAllInventory, arg.TenantID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListAllInventoryRow{}
	for rows.Next() {
		var i ListAllInventoryRow
		if err := rows.Scan(
			&i.ID,
			&i.ProductName,
			&i.Sku,
			&i.BatchNumber,
			&i.ExpiryDate,
			&i.Quantity,
			&i.UnitAbbreviation,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const reduceInventoryQuantity = `-- name: ReduceInventoryQuantity :exec
UPDATE inventory
SET quantity = quantity - $1
WHERE tenant_id = $2 AND product_id = $3 AND batch_id = $4
`

type ReduceInventoryQuantityParams struct {
	Quantity  pgtype.Numeric `json:"quantity"`
	TenantID  uuid.UUID      `json:"tenant_id"`
	ProductID uuid.UUID      `json:"product_id"`
	BatchID   uuid.UUID      `json:"batch_id"`
}

func (q *Queries) ReduceInventoryQuantity(ctx context.Context, arg ReduceInventoryQuantityParams) error {
	_, err := q.db.Exec(ctx, reduceInventoryQuantity,
		arg.Quantity,
		arg.TenantID,
		arg.ProductID,
		arg.BatchID,
	)
	return err
}

const setInventoryQuantity = `-- name: SetInventoryQuantity :exec
UPDATE inventory
SET quantity = $1
WHERE tenant_id = $2 AND product_id = $3 AND batch_id = $4
`

type SetInventoryQuantityParams struct {
	Quantity  pgtype.Numeric `json:"quantity"`
	TenantID  uuid.UUID      `json:"tenant_id"`
	ProductID uuid.UUID      `json:"product_id"`
	BatchID   uuid.UUID      `json:"batch_id"`
}

func (q *Queries) SetInventoryQuantity(ctx context.Context, arg SetInventoryQuantityParams) error {
	_, err := q.db.Exec(ctx, setInventoryQuantity,
		arg.Quantity,
		arg.TenantID,
		arg.ProductID,
		arg.BatchID,
	)
	return err
}

const updateBatch = `-- name: UpdateBatch :one
UPDATE batches
SET batch_number = $2, expiry_date = $3, cost = $4
WHERE id = $1 AND tenant_id = $5
RETURNING id, tenant_id, product_id, batch_number, expiry_date, cost, created_at
`

type UpdateBatchParams struct {
	ID          uuid.UUID      `json:"id"`
	BatchNumber string         `json:"batch_number"`
	ExpiryDate  time.Time      `json:"expiry_date"`
	Cost        pgtype.Numeric `json:"cost"`
	TenantID    uuid.UUID      `json:"tenant_id"`
}

func (q *Queries) UpdateBatch(ctx context.Context, arg UpdateBatchParams) (Batch, error) {
	row := q.db.QueryRow(ctx, updateBatch,
		arg.ID,
		arg.BatchNumber,
		arg.ExpiryDate,
		arg.Cost,
		arg.TenantID,
	)
	var i Batch
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.ProductID,
		&i.BatchNumber,
		&i.ExpiryDate,
		&i.Cost,
		&i.CreatedAt,
	)
	return i, err
}

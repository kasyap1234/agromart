// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: inventory.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const addInventoryQuantity = `-- name: AddInventoryQuantity :exec
INSERT INTO inventory (tenant_id, product_id, batch_id, quantity)
VALUES ($1, $2, $3, $4)
ON CONFLICT (tenant_id, product_id, batch_id)
DO UPDATE SET quantity = inventory.quantity + $4
`

type AddInventoryQuantityParams struct {
	TenantID  pgtype.UUID
	ProductID pgtype.UUID
	BatchID   pgtype.UUID
	Quantity  pgtype.Numeric
}

func (q *Queries) AddInventoryQuantity(ctx context.Context, arg AddInventoryQuantityParams) error {
	_, err := q.db.Exec(ctx, addInventoryQuantity,
		arg.TenantID,
		arg.ProductID,
		arg.BatchID,
		arg.Quantity,
	)
	return err
}

const createBatch = `-- name: CreateBatch :one
INSERT INTO batches (tenant_id, product_id, batch_number, expiry_date, cost)
VALUES ($1, $2, $3, $4, $5)
RETURNING id, tenant_id, product_id, batch_number, expiry_date, cost, created_at
`

type CreateBatchParams struct {
	TenantID    pgtype.UUID
	ProductID   pgtype.UUID
	BatchNumber string
	ExpiryDate  pgtype.Date
	Cost        pgtype.Numeric
}

func (q *Queries) CreateBatch(ctx context.Context, arg CreateBatchParams) (Batch, error) {
	row := q.db.QueryRow(ctx, createBatch,
		arg.TenantID,
		arg.ProductID,
		arg.BatchNumber,
		arg.ExpiryDate,
		arg.Cost,
	)
	var i Batch
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.ProductID,
		&i.BatchNumber,
		&i.ExpiryDate,
		&i.Cost,
		&i.CreatedAt,
	)
	return i, err
}

const createInventoryLog = `-- name: CreateInventoryLog :exec
INSERT INTO inventory_log (tenant_id, product_id, batch_id, transaction_type, quantity_change, reference_id, notes)
VALUES ($1, $2, $3, $4, $5, $6, $7)
`

type CreateInventoryLogParams struct {
	TenantID        pgtype.UUID
	ProductID       pgtype.UUID
	BatchID         pgtype.UUID
	TransactionType string
	QuantityChange  pgtype.Numeric
	ReferenceID     pgtype.UUID
	Notes           pgtype.Text
}

func (q *Queries) CreateInventoryLog(ctx context.Context, arg CreateInventoryLogParams) error {
	_, err := q.db.Exec(ctx, createInventoryLog,
		arg.TenantID,
		arg.ProductID,
		arg.BatchID,
		arg.TransactionType,
		arg.QuantityChange,
		arg.ReferenceID,
		arg.Notes,
	)
	return err
}

const getProductInventoryDetails = `-- name: GetProductInventoryDetails :many
SELECT b.batch_number, b.expiry_date, i.quantity
FROM inventory i
JOIN batches b ON i.batch_id = b.id
WHERE i.tenant_id = $1 AND i.product_id = $2
ORDER BY b.expiry_date ASC
`

type GetProductInventoryDetailsParams struct {
	TenantID  pgtype.UUID
	ProductID pgtype.UUID
}

type GetProductInventoryDetailsRow struct {
	BatchNumber string
	ExpiryDate  pgtype.Date
	Quantity    pgtype.Numeric
}

func (q *Queries) GetProductInventoryDetails(ctx context.Context, arg GetProductInventoryDetailsParams) ([]GetProductInventoryDetailsRow, error) {
	rows, err := q.db.Query(ctx, getProductInventoryDetails, arg.TenantID, arg.ProductID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetProductInventoryDetailsRow
	for rows.Next() {
		var i GetProductInventoryDetailsRow
		if err := rows.Scan(&i.BatchNumber, &i.ExpiryDate, &i.Quantity); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getProductQuantity = `-- name: GetProductQuantity :one
SELECT COALESCE(SUM(quantity), 0) AS total_quantity
FROM inventory
WHERE tenant_id = $1 AND product_id = $2
`

type GetProductQuantityParams struct {
	TenantID  pgtype.UUID
	ProductID pgtype.UUID
}

func (q *Queries) GetProductQuantity(ctx context.Context, arg GetProductQuantityParams) (interface{}, error) {
	row := q.db.QueryRow(ctx, getProductQuantity, arg.TenantID, arg.ProductID)
	var total_quantity interface{}
	err := row.Scan(&total_quantity)
	return total_quantity, err
}

const reduceInventoryQuantity = `-- name: ReduceInventoryQuantity :exec
UPDATE inventory
SET quantity = quantity - $1
WHERE tenant_id = $2 AND product_id = $3 AND batch_id = $4
`

type ReduceInventoryQuantityParams struct {
	Quantity  pgtype.Numeric
	TenantID  pgtype.UUID
	ProductID pgtype.UUID
	BatchID   pgtype.UUID
}

func (q *Queries) ReduceInventoryQuantity(ctx context.Context, arg ReduceInventoryQuantityParams) error {
	_, err := q.db.Exec(ctx, reduceInventoryQuantity,
		arg.Quantity,
		arg.TenantID,
		arg.ProductID,
		arg.BatchID,
	)
	return err
}

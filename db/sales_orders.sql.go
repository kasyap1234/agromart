// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: sales_orders.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createSalesOrder = `-- name: CreateSalesOrder :one
INSERT INTO sales_orders (tenant_id, so_number, customer_id, location_id, created_by)
VALUES ($1, $2, $3, $4, $5)
RETURNING id, tenant_id, so_number, customer_id, location_id, order_date, expected_delivery_date, actual_delivery_date, total_amount, tax_amount, discount_amount, final_amount, status, notes, created_by, approved_by, approved_at, created_at, updated_at
`

type CreateSalesOrderParams struct {
	TenantID   pgtype.UUID
	SoNumber   string
	CustomerID pgtype.UUID
	LocationID pgtype.UUID
	CreatedBy  pgtype.UUID
}

func (q *Queries) CreateSalesOrder(ctx context.Context, arg CreateSalesOrderParams) (SalesOrder, error) {
	row := q.db.QueryRow(ctx, createSalesOrder,
		arg.TenantID,
		arg.SoNumber,
		arg.CustomerID,
		arg.LocationID,
		arg.CreatedBy,
	)
	var i SalesOrder
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.SoNumber,
		&i.CustomerID,
		&i.LocationID,
		&i.OrderDate,
		&i.ExpectedDeliveryDate,
		&i.ActualDeliveryDate,
		&i.TotalAmount,
		&i.TaxAmount,
		&i.DiscountAmount,
		&i.FinalAmount,
		&i.Status,
		&i.Notes,
		&i.CreatedBy,
		&i.ApprovedBy,
		&i.ApprovedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createSalesOrderItem = `-- name: CreateSalesOrderItem :one
INSERT INTO sales_order_items (tenant_id, sales_order_id, product_id, quantity_ordered, unit_price, total_price)
VALUES ($1, $2, $3, $4, $5, $6)
RETURNING id, tenant_id, sales_order_id, product_id, batch_id, quantity_ordered, quantity_shipped, unit_price, total_price, tax_percent, discount_percent, notes, created_at, updated_at
`

type CreateSalesOrderItemParams struct {
	TenantID        pgtype.UUID
	SalesOrderID    pgtype.UUID
	ProductID       pgtype.UUID
	QuantityOrdered pgtype.Numeric
	UnitPrice       pgtype.Numeric
	TotalPrice      pgtype.Numeric
}

func (q *Queries) CreateSalesOrderItem(ctx context.Context, arg CreateSalesOrderItemParams) (SalesOrderItem, error) {
	row := q.db.QueryRow(ctx, createSalesOrderItem,
		arg.TenantID,
		arg.SalesOrderID,
		arg.ProductID,
		arg.QuantityOrdered,
		arg.UnitPrice,
		arg.TotalPrice,
	)
	var i SalesOrderItem
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.SalesOrderID,
		&i.ProductID,
		&i.BatchID,
		&i.QuantityOrdered,
		&i.QuantityShipped,
		&i.UnitPrice,
		&i.TotalPrice,
		&i.TaxPercent,
		&i.DiscountPercent,
		&i.Notes,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getSalesOrder = `-- name: GetSalesOrder :one
SELECT id, tenant_id, so_number, customer_id, location_id, order_date, expected_delivery_date, actual_delivery_date, total_amount, tax_amount, discount_amount, final_amount, status, notes, created_by, approved_by, approved_at, created_at, updated_at FROM sales_orders
WHERE id = $1 AND tenant_id = $2
`

type GetSalesOrderParams struct {
	ID       pgtype.UUID
	TenantID pgtype.UUID
}

func (q *Queries) GetSalesOrder(ctx context.Context, arg GetSalesOrderParams) (SalesOrder, error) {
	row := q.db.QueryRow(ctx, getSalesOrder, arg.ID, arg.TenantID)
	var i SalesOrder
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.SoNumber,
		&i.CustomerID,
		&i.LocationID,
		&i.OrderDate,
		&i.ExpectedDeliveryDate,
		&i.ActualDeliveryDate,
		&i.TotalAmount,
		&i.TaxAmount,
		&i.DiscountAmount,
		&i.FinalAmount,
		&i.Status,
		&i.Notes,
		&i.CreatedBy,
		&i.ApprovedBy,
		&i.ApprovedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getSalesOrderItems = `-- name: GetSalesOrderItems :many
SELECT id, tenant_id, sales_order_id, product_id, batch_id, quantity_ordered, quantity_shipped, unit_price, total_price, tax_percent, discount_percent, notes, created_at, updated_at FROM sales_order_items
WHERE sales_order_id = $1 AND tenant_id = $2
`

type GetSalesOrderItemsParams struct {
	SalesOrderID pgtype.UUID
	TenantID     pgtype.UUID
}

func (q *Queries) GetSalesOrderItems(ctx context.Context, arg GetSalesOrderItemsParams) ([]SalesOrderItem, error) {
	rows, err := q.db.Query(ctx, getSalesOrderItems, arg.SalesOrderID, arg.TenantID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SalesOrderItem
	for rows.Next() {
		var i SalesOrderItem
		if err := rows.Scan(
			&i.ID,
			&i.TenantID,
			&i.SalesOrderID,
			&i.ProductID,
			&i.BatchID,
			&i.QuantityOrdered,
			&i.QuantityShipped,
			&i.UnitPrice,
			&i.TotalPrice,
			&i.TaxPercent,
			&i.DiscountPercent,
			&i.Notes,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateSalesOrderStatus = `-- name: UpdateSalesOrderStatus :exec
UPDATE sales_orders
SET status = $1
WHERE id = $2 AND tenant_id = $3
`

type UpdateSalesOrderStatusParams struct {
	Status   string
	ID       pgtype.UUID
	TenantID pgtype.UUID
}

func (q *Queries) UpdateSalesOrderStatus(ctx context.Context, arg UpdateSalesOrderStatusParams) error {
	_, err := q.db.Exec(ctx, updateSalesOrderStatus, arg.Status, arg.ID, arg.TenantID)
	return err
}

// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: sales_orders.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createSalesOrder = `-- name: CreateSalesOrder :one
INSERT INTO sales_orders (tenant_id, so_number, customer_id, location_id, created_by)
VALUES ($1, $2, $3, $4, $5)
RETURNING id, tenant_id, so_number, customer_id, location_id, order_date, expected_delivery_date, actual_delivery_date, total_amount, tax_amount, discount_amount, final_amount, status, notes, created_by, approved_by, approved_at, created_at, updated_at
`

type CreateSalesOrderParams struct {
	TenantID   pgtype.UUID
	SoNumber   string
	CustomerID pgtype.UUID
	LocationID pgtype.UUID
	CreatedBy  pgtype.UUID
}

func (q *Queries) CreateSalesOrder(ctx context.Context, arg CreateSalesOrderParams) (SalesOrder, error) {
	row := q.db.QueryRow(ctx, createSalesOrder,
		arg.TenantID,
		arg.SoNumber,
		arg.CustomerID,
		arg.LocationID,
		arg.CreatedBy,
	)
	var i SalesOrder
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.SoNumber,
		&i.CustomerID,
		&i.LocationID,
		&i.OrderDate,
		&i.ExpectedDeliveryDate,
		&i.ActualDeliveryDate,
		&i.TotalAmount,
		&i.TaxAmount,
		&i.DiscountAmount,
		&i.FinalAmount,
		&i.Status,
		&i.Notes,
		&i.CreatedBy,
		&i.ApprovedBy,
		&i.ApprovedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createSalesOrderItem = `-- name: CreateSalesOrderItem :one
INSERT INTO sales_order_items (tenant_id, sales_order_id, product_id, quantity_ordered, unit_price, total_price)
VALUES ($1, $2, $3, $4, $5, $6)
RETURNING id, tenant_id, sales_order_id, product_id, batch_id, quantity_ordered, quantity_shipped, unit_price, total_price, tax_percent, discount_percent, notes, created_at, updated_at
`

type CreateSalesOrderItemParams struct {
	TenantID        pgtype.UUID
	SalesOrderID    pgtype.UUID
	ProductID       pgtype.UUID
	QuantityOrdered pgtype.Numeric
	UnitPrice       pgtype.Numeric
	TotalPrice      pgtype.Numeric
}

func (q *Queries) CreateSalesOrderItem(ctx context.Context, arg CreateSalesOrderItemParams) (SalesOrderItem, error) {
	row := q.db.QueryRow(ctx, createSalesOrderItem,
		arg.TenantID,
		arg.SalesOrderID,
		arg.ProductID,
		arg.QuantityOrdered,
		arg.UnitPrice,
		arg.TotalPrice,
	)
	var i SalesOrderItem
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.SalesOrderID,
		&i.ProductID,
		&i.BatchID,
		&i.QuantityOrdered,
		&i.QuantityShipped,
		&i.UnitPrice,
		&i.TotalPrice,
		&i.TaxPercent,
		&i.DiscountPercent,
		&i.Notes,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getCustomerSalesSummary = `-- name: GetCustomerSalesSummary :many
SELECT
    c.name AS customer_name,
    SUM(so.final_amount) AS total_sales_amount,
    COUNT(so.id) AS total_orders
FROM customers c
JOIN sales_orders so ON c.id = so.customer_id AND c.tenant_id = so.tenant_id
WHERE c.tenant_id = $1
GROUP BY c.id, c.name
ORDER BY total_sales_amount DESC
`

type GetCustomerSalesSummaryRow struct {
	CustomerName     string
	TotalSalesAmount int64
	TotalOrders      int64
}

func (q *Queries) GetCustomerSalesSummary(ctx context.Context, tenantID pgtype.UUID) ([]GetCustomerSalesSummaryRow, error) {
	rows, err := q.db.Query(ctx, getCustomerSalesSummary, tenantID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetCustomerSalesSummaryRow
	for rows.Next() {
		var i GetCustomerSalesSummaryRow
		if err := rows.Scan(&i.CustomerName, &i.TotalSalesAmount, &i.TotalOrders); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSalesOrder = `-- name: GetSalesOrder :one
SELECT id, tenant_id, so_number, customer_id, location_id, order_date, expected_delivery_date, actual_delivery_date, total_amount, tax_amount, discount_amount, final_amount, status, notes, created_by, approved_by, approved_at, created_at, updated_at FROM sales_orders
WHERE id = $1 AND tenant_id = $2
`

type GetSalesOrderParams struct {
	ID       pgtype.UUID
	TenantID pgtype.UUID
}

func (q *Queries) GetSalesOrder(ctx context.Context, arg GetSalesOrderParams) (SalesOrder, error) {
	row := q.db.QueryRow(ctx, getSalesOrder, arg.ID, arg.TenantID)
	var i SalesOrder
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.SoNumber,
		&i.CustomerID,
		&i.LocationID,
		&i.OrderDate,
		&i.ExpectedDeliveryDate,
		&i.ActualDeliveryDate,
		&i.TotalAmount,
		&i.TaxAmount,
		&i.DiscountAmount,
		&i.FinalAmount,
		&i.Status,
		&i.Notes,
		&i.CreatedBy,
		&i.ApprovedBy,
		&i.ApprovedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getSalesOrderItemByID = `-- name: GetSalesOrderItemByID :one
SELECT id, tenant_id, sales_order_id, product_id, batch_id, quantity_ordered, quantity_shipped, unit_price, total_price, tax_percent, discount_percent, notes, created_at, updated_at FROM sales_order_items
WHERE id = $1 AND tenant_id = $2
`

type GetSalesOrderItemByIDParams struct {
	ID       pgtype.UUID
	TenantID pgtype.UUID
}

func (q *Queries) GetSalesOrderItemByID(ctx context.Context, arg GetSalesOrderItemByIDParams) (SalesOrderItem, error) {
	row := q.db.QueryRow(ctx, getSalesOrderItemByID, arg.ID, arg.TenantID)
	var i SalesOrderItem
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.SalesOrderID,
		&i.ProductID,
		&i.BatchID,
		&i.QuantityOrdered,
		&i.QuantityShipped,
		&i.UnitPrice,
		&i.TotalPrice,
		&i.TaxPercent,
		&i.DiscountPercent,
		&i.Notes,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getSalesOrderItems = `-- name: GetSalesOrderItems :many
SELECT id, tenant_id, sales_order_id, product_id, batch_id, quantity_ordered, quantity_shipped, unit_price, total_price, tax_percent, discount_percent, notes, created_at, updated_at FROM sales_order_items
WHERE sales_order_id = $1 AND tenant_id = $2
`

type GetSalesOrderItemsParams struct {
	SalesOrderID pgtype.UUID
	TenantID     pgtype.UUID
}

func (q *Queries) GetSalesOrderItems(ctx context.Context, arg GetSalesOrderItemsParams) ([]SalesOrderItem, error) {
	rows, err := q.db.Query(ctx, getSalesOrderItems, arg.SalesOrderID, arg.TenantID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SalesOrderItem
	for rows.Next() {
		var i SalesOrderItem
		if err := rows.Scan(
			&i.ID,
			&i.TenantID,
			&i.SalesOrderID,
			&i.ProductID,
			&i.BatchID,
			&i.QuantityOrdered,
			&i.QuantityShipped,
			&i.UnitPrice,
			&i.TotalPrice,
			&i.TaxPercent,
			&i.DiscountPercent,
			&i.Notes,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSalesReportByDate = `-- name: GetSalesReportByDate :many
SELECT
    p.name as product_name,
    SUM(soi.quantity_shipped) as total_units_sold,
    SUM(soi.total_price) as total_revenue
FROM sales_order_items soi
JOIN products p ON soi.product_id = p.id
JOIN sales_orders so ON soi.sales_order_id = so.id
WHERE soi.tenant_id = $1
  AND so.order_date BETWEEN $2 AND $3
  AND so.status = 'DELIVERED' -- or 'SHIPPED'
GROUP BY p.name
ORDER BY total_revenue DESC
`

type GetSalesReportByDateParams struct {
	TenantID    pgtype.UUID
	OrderDate   pgtype.Date
	OrderDate_2 pgtype.Date
}

type GetSalesReportByDateRow struct {
	ProductName    string
	TotalUnitsSold int64
	TotalRevenue   int64
}

func (q *Queries) GetSalesReportByDate(ctx context.Context, arg GetSalesReportByDateParams) ([]GetSalesReportByDateRow, error) {
	rows, err := q.db.Query(ctx, getSalesReportByDate, arg.TenantID, arg.OrderDate, arg.OrderDate_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetSalesReportByDateRow
	for rows.Next() {
		var i GetSalesReportByDateRow
		if err := rows.Scan(&i.ProductName, &i.TotalUnitsSold, &i.TotalRevenue); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listSalesOrdersByCustomer = `-- name: ListSalesOrdersByCustomer :many
SELECT id, tenant_id, so_number, customer_id, location_id, order_date, expected_delivery_date, actual_delivery_date, total_amount, tax_amount, discount_amount, final_amount, status, notes, created_by, approved_by, approved_at, created_at, updated_at FROM sales_orders
WHERE tenant_id = $1 AND customer_id = $2
ORDER BY order_date DESC
LIMIT $3 OFFSET $4
`

type ListSalesOrdersByCustomerParams struct {
	TenantID   pgtype.UUID
	CustomerID pgtype.UUID
	Limit      int32
	Offset     int32
}

func (q *Queries) ListSalesOrdersByCustomer(ctx context.Context, arg ListSalesOrdersByCustomerParams) ([]SalesOrder, error) {
	rows, err := q.db.Query(ctx, listSalesOrdersByCustomer,
		arg.TenantID,
		arg.CustomerID,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SalesOrder
	for rows.Next() {
		var i SalesOrder
		if err := rows.Scan(
			&i.ID,
			&i.TenantID,
			&i.SoNumber,
			&i.CustomerID,
			&i.LocationID,
			&i.OrderDate,
			&i.ExpectedDeliveryDate,
			&i.ActualDeliveryDate,
			&i.TotalAmount,
			&i.TaxAmount,
			&i.DiscountAmount,
			&i.FinalAmount,
			&i.Status,
			&i.Notes,
			&i.CreatedBy,
			&i.ApprovedBy,
			&i.ApprovedAt,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateSalesOrderItemQuantityShipped = `-- name: UpdateSalesOrderItemQuantityShipped :one
UPDATE sales_order_items
SET quantity_shipped = $2, updated_at = NOW()
WHERE id = $1 AND tenant_id = $3
RETURNING id, tenant_id, sales_order_id, product_id, batch_id, quantity_ordered, quantity_shipped, unit_price, total_price, tax_percent, discount_percent, notes, created_at, updated_at
`

type UpdateSalesOrderItemQuantityShippedParams struct {
	ID              pgtype.UUID
	QuantityShipped pgtype.Numeric
	TenantID        pgtype.UUID
}

func (q *Queries) UpdateSalesOrderItemQuantityShipped(ctx context.Context, arg UpdateSalesOrderItemQuantityShippedParams) (SalesOrderItem, error) {
	row := q.db.QueryRow(ctx, updateSalesOrderItemQuantityShipped, arg.ID, arg.QuantityShipped, arg.TenantID)
	var i SalesOrderItem
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.SalesOrderID,
		&i.ProductID,
		&i.BatchID,
		&i.QuantityOrdered,
		&i.QuantityShipped,
		&i.UnitPrice,
		&i.TotalPrice,
		&i.TaxPercent,
		&i.DiscountPercent,
		&i.Notes,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateSalesOrderStatus = `-- name: UpdateSalesOrderStatus :exec
UPDATE sales_orders
SET status = $1
WHERE id = $2 AND tenant_id = $3
`

type UpdateSalesOrderStatusParams struct {
	Status   string
	ID       pgtype.UUID
	TenantID pgtype.UUID
}

func (q *Queries) UpdateSalesOrderStatus(ctx context.Context, arg UpdateSalesOrderStatusParams) error {
	_, err := q.db.Exec(ctx, updateSalesOrderStatus, arg.Status, arg.ID, arg.TenantID)
	return err
}
